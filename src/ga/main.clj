(ns ga.main (:gen-class ))

(defstruct member :fitness :value)

;helper functions
(defn zip 
  "helper function which pairs values in two lists xs ys" 
  [xs ys]
  (loop [pairs (transient []) l1 xs l2 ys]
    (if (or (empty? l1) (empty? l2))
      (persistent! pairs)
      (recur (conj! pairs [(first l1) (first l2)]) (rest l1) (rest l2)))))
      
(defn rand-in-range 
  "generates a random value within the given range"
  [min max]
  (int (+ (* (Math/random) (inc (- max min))) min)))

;functions for evolving members
(defn- mutate 
  "randomly mutates values in members of the population using the mutator function"
  [population mutator threshold]  
  (doseq [member population]                    
      (let [old-val (:value @member)
            new-val (map #(if (< (rand) threshold) (mutator) %1) old-val)]
      (swap! member #(assoc %1 :value new-val)))))

(defn- rank 
  "ranks the members of the population using the val-comp function and the target value"
  [population val-comp target]
  (doseq [member population]
    (swap! member #(assoc %1 :fitness (val-comp (:value %1) target))))
  (reverse (sort #(compare (:fitness @%1) (:fitness @%2)) population)))

(defn- fit? 
  "checks if population has any members which match the desired value"
  [population]
  (> (count (filter #(== (:fitness @%1) 0) population)) 0))

(defn- mate 
  "cross-breeds existing members to produce offspring
  values are generated by randomly  combining first and second 
  halves of members of the population."
  [members]
  (let [halves (split-at (/ (count members) 2) members)]
    (loop [new-members (transient []) m1 (first halves) m2 (second halves)]   
       (if (or (empty? m1) (empty? m2))
         (persistent! new-members)
         (let [values (if (> (rand) 0.5) 
                        [(:value @(first m1)) (:value @(first m2))]
                        [(:value @(first m2)) (:value @(first m1))])
               val (concat (take (/ (count (first values)) 2) (first values)) 
                     (drop (/ (count (second values)) 2) (second values)))]
           (recur (conj! new-members (atom (struct member nil val)))
                  (rest m1) (rest m2)))))))
                    
(defn- evolve-step 
  "mutates the populationtakes then combines the top members 
   of the population with some of the bottom members to promote 
   genetic diversity, and adds some offspring"
  [population mutator threshold target]                 
  (mutate population mutator threshold)
  (let [promote-size (/ (count population) 5)
        keep-size    (- (/ (count population) 2) promote-size)
        parts (split-at keep-size population)]      
      (concat (first parts)
              (take promote-size (second parts))
              (mate population))))

(defn- gen-member [mutator target]
    (struct member nil (for [i (range 0 (count target))] (mutator))))
  
(defn- init-population 
  "creates a population using the generator function"
  [size mutator target]
  (for [i (range 0 size)] (atom (gen-member mutator target))))

(defn evolve 
   "generates the initial population and ranks it, then runs the evolve-step until 
    the solution is found"
   [size threshold target mutator comp]   
  (loop [population (init-population size mutator target)]
    (let [ranked (rank population comp target)]
      (if (fit? ranked)
        ranked
        (recur (evolve-step ranked mutator threshold target))))))
